
CausalArima<-function(y, auto = TRUE, order = c(0, 0, 0), seasonal = c(0, 0, 0), ic = "aic", xreg = NULL, dates,
                      int.date, arima.args = list(), auto.args = list(), nboot = NULL, model = NULL){
  
  ### param checks
  if(class(y) != "ts") stop("y must be an object of class ts")
  if(!missing(xreg)) {
    if(!is.matrix(xreg) && !is.data.frame(xreg) && !is.numeric(xreg))
      stop("`xreg` must be a numeric vector, matrix or data.frame")
    xreg <- as.matrix(xreg)
    if(nrow(xreg) != length(y)) stop("nrow(xreg) != length(y)")
  }
  if(!any(class(dates) %in% c("Date", "POSIXct", "POSIXlt", "POSIXt")))
    stop("`dates` must be a vector of class Date")
  if(length(dates) != length(y)) stop("length(dates) != length(y)")
  if(length(int.date) != 1 || !any(class(dates) %in% c("Date", "POSIXct", "POSIXlt", "POSIXt")))
    stop("`int.date` must be a Date of length 1")
  # if(alpha <0 | alpha >1) stop("alpha must be between 0 and 1")
  # if(!missing(horizon) && !any(class(horizon) %in% c("Date", "POSIXct", "POSIXlt", "POSIXt")))
    # stop("`horizon` must be a Date object")
  if(!missing(nboot) && !is.numeric(nboot)) stop("`nboot` must be numeric")
  
  ### STEP 1. Subsetting the data: before and after the intervention date
  ind<-dates>=int.date
  y.00<-y[!ind]
  y.01<-y[ind]
  
  if(!is.null(xreg)) {
    xreg0<-xreg[!ind,]
    xreg1<-xreg[ind,]
    
  } else {
    xreg0 <- NULL
    xreg1 <- NULL
  }
  
  ### STEP 2. Model estimation in the pre-intervention period
  start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
  
  # if(auto){
  #   model <- do.call("auto.arima", c(list(y = ts(y.00, start = start, frequency = frequency(y))),
  #                                   list(ic = ic), list(xreg = xreg0), auto.args))
  # } else {
  #  model <- do.call("Arima", c(list(y = ts(y.00, start = start, frequency = frequency(y))),
  #                              list(order = order), list(seasonal = seasonal), list(xreg = xreg0),
  #                              arima.args))
  #}
  
  if(auto){
    model <- do.call("auto.arima", c(list(y = ts(y.00, start = start, frequency = frequency(y))),
                                     list(ic = ic), list(xreg = xreg0), auto.args))
  } else if(!is.null(model)){
    
    model <- model
    
  } else {
    
    model <- do.call("Arima", c(list(y = ts(y.00, start = start, frequency = frequency(y))),
                                list(order = order), list(seasonal = seasonal), list(xreg = xreg0),
                                arima.args))
  }
  
  ### STEP 3. Forecasting the counterfactual outcome in the absence of intervention
  h<-length(y.01)
  fcast<-forecast(model, xreg = xreg1, h = h)
  mean.fcast.0<-as.numeric(fcast$mean)
  
  # Check
  if(sum(y<0, na.rm = T)==0 & sum(mean.fcast.0<0, na.rm = T)>0){print("warning: negative forecasts for a positive variable")
    print(mean.fcast.0[mean.fcast.0<0])}
  if(sum(y<0, na.rm = T)==0 & sum(model$fitted<0, na.rm = T)>0){"warning: negative fitted for a positive variable"}
  
  ### STEP 4. Causal effect computation: direct comparison between the observed outcome (y.01) and the
  #           predicted counterfactual (mean.fcast.0)
  causal.effect.0 <- y.01 - mean.fcast.0
  
  ### STEP 5. Test statistics
  
  ## Extracting
  d <- model$arma[6]; D <- model$arma[7]; S <- model$arma[5]
  coef <- model$coef
  sig2 <- model$sigma2
  ar  <- coef[ substr(names(coef), 1, 2) == "ar"  ]
  ma  <- coef[ substr(names(coef), 1, 2) == "ma"  ]
  sar <- coef[ substr(names(coef), 1, 3) == "sar" ]
  sma <- coef[ substr(names(coef), 1, 3) == "sma" ]
  
  ## MA(inf)
  par <- .sarma2larma(ar = ar, ma = ma, sar = sar, sma = sma, S = S)  
  psi <- c(1, ARMAtoMA(ar = par$ar, ma = par$ma, lag.max = h-1))
  
  ## Stats (tau, sum.tau, avg.tau)
  # Removing NA's
  psi <- psi[!is.na(causal.effect.0)]
  tau  <- causal.effect.0[!is.na(causal.effect.0)]
  sum.tau <- cumsum(tau)
  avg.tau <- cumsum(tau) / seq(1, length(tau), 1)
  
  # Gaussian based inference
  norm <- .norm.inf(stat1 = tau, stat2 = sum.tau, stat3 = avg.tau, sig2 = sig2, psi = psi)
  
  # Bootstrap based inference
  
  boot <- if ( NROW(nboot) > 0 && is.finite(nboot) && nboot >= 1)
  {
    nboot <- round(nboot[1])
    .boot.inf(stat1 = tau, stat2 = sum.tau, stat3 = avg.tau, psi = psi, res = residuals(model), 
              nrep = nboot)
  } 
  else
  {
    NULL
  }   
  
  ### STEP 6. Saving results
  my_list <- list(model = model, dates = dates, causal.effect = causal.effect.0, int.date = int.date, norm = norm, boot = boot)
  class(my_list) <- "cArima"
  return(my_list)
  
}

# ------------------------------------------------------------------------------

##################################################################################
## Merge AR(p) and SAR(P); the same for MA(q) and SMA(Q)
##################################################################################

.sarma2larma <- function(ar = NULL, ma = NULL, sar = NULL, sma = NULL, S = 12)
{
  #### Adjust
  if ( NROW(ar) > 0 ) { ar <- -ar }
  if ( NROW(sar) > 0 ) { sar <- -sar }
  
  #### model
  list(
    ar = -.long(p = ar, ps = sar, s = S),
    ma =  .long(p = ma, ps = sma, s = S) )
}


##################################################################################
## Merge short and seasonal components
##################################################################################

.long <- function(p, ps, s)
{
  #### Settings
  np  <- NROW( p )
  nps <- NROW( ps )
  
  ####
  cp  <- if ( np > 0 ) { c(1, p) } else { 1 }
  cps <- if ( nps > 0 )
  {
    ind <- seq(from = s, by = s, length.out = nps)
    x1 <- numeric(s * nps)
    x1[ind] <- ps
    c(1, x1)
  }
  else
  {
    1
  }
  
  #### Answer
  convolve(cp, rev(cps), type = "open")[-1]
}


##################################################################################
## Compute variance of the point, cumulative and temporal average effect (see pdf)
##################################################################################

.norm.inf <- function(stat1, stat2, stat3, sig2, psi)
{
  #### Settings
  np <- NROW(psi)
  
  ## Stat 1: tau ~ Normal 
  psi1 <- psi
  sd1  <- sqrt(sig2 * cumsum(psi^2))
  z1 <- (stat1 - 0) / sd1
  ## Stat 2: delta ~ Normal
  psi2 <- cumsum(psi)
  sd2  <- sqrt(sig2 * cumsum(psi2^2))
  z2 <- (stat2 - 0) / sd2
  ## Stat 3: avg.tau ~ Normal
  sd3 <- sd2 / seq(1, np, 1)
  z3 <- (stat3 - 0) / sd3
  #### Gaussian based inference
  inf <- cbind(
    tau = stat1, sd.tau = sd1, 
    pvalue.tau.l = pnorm(z1), pvalue.tau.b = 2 * (1 - pnorm(abs(z1))), pvalue.tau.r = 1 - pnorm(z1), 
    sum.tau = stat2, sd.sum = sd2, 
    pvalue.sum.l = pnorm(z2), pvalue.sum.b = 2 * (1 - pnorm(abs(z2))), pvalue.sum.r = 1 - pnorm(z2),
    avg.tau = stat3, sd.avg = sd3,
    pvalue.avg.l = pnorm(z3), pvalue.avg.b = 2 * (1 - pnorm(abs(z3))), pvalue.avg.r = 1 - pnorm(z3)) 
  
  #### Answer
  list(type = "norm", inf = inf)
}

# ------------------------------------------------------------------------------
.boot.inf <- function(stat1, stat2, stat3, psi, res, nrep)
{
  #### Settings
  np <- NROW(psi)
  psi1 <- psi
  psi2 <- cumsum(psi)
  fun <- function(eps, psi)
  {
    convolve(eps, psi, conj = FALSE, type = "open")[NROW(eps):(2*NROW(eps)-1)]
  }
  
  #### Remove NA from res
  res <- na.omit(as.numeric(res))
  #### Bootstrap residuals
  bootm <- as.data.frame( 
    matrix( sample(x = res, size = np * nrep, replace = TRUE), np, nrep ) )
  
  #### stat1 (arrange by row, replications by col)
  boot1 <- mapply(FUN = fun, eps = bootm, MoreArgs = list(psi = psi1))
  #### stat2 (arrange by row, replications by col)
  boot2 <- mapply(FUN = fun, eps = bootm, MoreArgs = list(psi = psi2))
  #### stat3
  boot3 <- boot2 / seq(1, np, 1)
  
  #### p-values
  pv1.l <- pv1.b <- pv1.r <- pv2.l <- pv2.b <- pv2.r <- pv3.l <- pv3.b <- pv3.r <- rep.int(NA, np) 
  for (i in 1 : np)
  {
    stat <- stat1[i]
    boot <- boot1[i, ]
    pv1.l[i] <- mean(boot < stat)
    pv1.b[i] <- mean( boot < -abs(stat) | boot > abs(stat) )
    pv1.r[i] <- mean(stat < boot)
    stat <- stat2[i]
    boot <- boot2[i, ]
    pv2.l[i] <- mean(boot < stat)
    pv2.b[i] <- mean( boot < -abs(stat) | boot > abs(stat) )
    pv2.r[i] <- mean(stat < boot)
    stat <- stat3[i]
    boot <- boot3[i, ]
    pv3.l[i] <- mean(boot < stat)
    pv3.b[i] <- mean( boot < -abs(stat) | boot > abs(stat) )
    pv3.r[i] <- mean(stat < boot)
  }
  
  #### Inference
  inf <- cbind(
    tau = stat1, 
    pvalue.tau.l = pv1.l, pvalue.tau.b = pv1.b, pvalue.tau.r = pv1.r, 
    sum.tau = stat2, 
    pvalue.sum.l = pv2.l, pvalue.sum.b = pv2.b, pvalue.sum.r = pv2.r,
    avg.tau = stat3,
    pvalue.avg.l = pv3.l, pvalue.avg.b = pv3.b, pvalue.avg.r = pv3.r) 
  
  #### Answer
  list(type = "bootstrap", nrep = nrep, inf = inf, boot1 = boot1, boot2 = boot2, boot3 = boot3)
}

# ------------------------------------------------------------------------------

# Summary method for objects of class 'cArima'

summary.cArima<- function(cArima, type, horizon = NULL){
  
  if(!is.null(horizon)){
    
    ## Settings & removing NA's
    int.date <- cArima$int.date
    dates <- cArima$dates
    ind <- which(dates[dates >= int.date][!is.na(cArima$causal.effect)] %in% horizon)
    ncol <- 1 + dim(cArima[[type]]$inf)[2]
    summary <- data.frame(matrix(nrow = length(horizon), ncol = ncol))
    colnames(summary) <- c("Time horizon", colnames(cArima[[type]]$inf))
    summary[, 1] <- horizon
    summary[, 2:ncol] <- cArima[[type]]$inf[ind, ]
    summary
    
  } else {
    h <- dim(cArima[[type]]$inf)[1]
    cArima[[type]]$inf[h, ]
  }
}

# ------------------------------------------------------------------------------
effect_table <- function(list.results, type, stat, direction, horizon, digits = 2){
  
  effect.table <- unlist(lapply(lapply(list.results, FUN = table.cArima, type = type, stat = stat, 
                                       direction = direction, horizon = horizon, digits = digits), function(x)(t(x))))
  
  if (type == "norm"){
    tab <- matrix(effect.table, nrow = length(list.results)*2, ncol = length(horizon), byrow = TRUE)
  } else {
    tab <- matrix(effect.table, nrow = length(list.results), ncol = length(horizon), byrow = TRUE)
  }
  
  tab
}

# ------------------------------------------------------------------------------ 
table.cArima <- function(cArima, type, stat, direction, horizon, digits = 2){
  
  # Settings
  
  if(stat %in% c("sum", "avg")){
    stat2 <- paste(stat, ".tau", sep = "")
  } else {
    stat2 <- stat
  }
  
  tab <- matrix(NA, nrow = 1, ncol = length(horizon))
  colnames(tab) <- paste(stat2, horizon)
  star. <- star(summary(cArima, type = type, horizon = horizon)[, paste("pvalue.", stat, ".", direction, sep = "")])
 
  # Table
  tab[1,] <- paste(round(summary(cArima, type = type, horizon = horizon)[, paste(stat2)], digits = digits), "^{", star., "}", sep="" )
  tab[1,] <- gsub(tab[1,], pattern = "\\^\\{ \\}", replacement = "")
  
  if(type == "norm"){
    tab <- rbind(tab, paste("(",round(summary(cArima, type = type, horizon = horizon)[, paste("sd.", stat, sep = "")], digits = digits),")", sep = ""))
    } 
  
  tab
}

star <- function(pvalue){
  star <- rep(NA, times = length(pvalue))
  ind  <- abs(pvalue) < 0.001 
  ind2 <- abs(pvalue) < 0.01 & abs(pvalue) >= 0.001
  ind3 <- abs(pvalue) < 0.05 & abs(pvalue) >= 0.01
  ind4 <- abs(pvalue) < 0.1 &  abs(pvalue) >= 0.05
  star[ind] <- "***" ; star[ind2] <- "**" ; star[ind3]<- "*"
  star[ind4] <- "." ; star[!ind & !ind2 & !ind3 & !ind4] <- " "
  star
}
