g[[j]] <- ggplot(data = dat, aes(x = x)) +  coord_cartesian(ylim = ylim) + labs(title = main, subtitle = sub, y = "", x = "") +
geom_line(aes(y = y), color = "navy") +
geom_ribbon(aes(x = x, ymax = y.upper, ymin = y.lower), fill="steelblue", alpha=.5)
}
do.call(grid.arrange, c(g, ...))
}
}
.impact(ce, int.date = int.date, ncol = 2)
.impact <- function(cArima, int.date, ...){
dates <- cArima$dates
if(!is.list(cArima$effect)){
x <- dates[dates >= int.date]
main <- "Point effect"
dat <- data.frame(x = x, y = cArima$effect.mean, y.upper = cArima$effect.upper, y.lower = cArima$effect.lower)
ylim <- c(min(dat[, "y.lower"]), max(dat[, "y.upper"]))
ggplot(data = dat, aes(x = x)) +  coord_cartesian(ylim = ylim) + labs(title = main, y = "", x = "") +
geom_line(aes(y = y), color = "navy") +
geom_ribbon(aes(x = x, ymax = y.upper, ymin = y.lower), fill="steelblue", alpha=.5)
} else {
g <- list()
for(i in 1:length(cArima$effect)){
start <- which(dates == int.date)
end <- start + length(cArima$forecast.mean[[i]])
x <- dates[start:(end -1)]
dat <- data.frame(x = x, y = cArima$effect.mean[[i]], y.upper = cArima$effect.upper[[i]], y.lower = cArima$effect.lower[[i]])
ylim <- c(min(dat[, "y.lower"]), max(dat[, "y.upper"]))
main <- paste("Point effect")
sub <- paste("Time horizon ", i, sep = "")
g[[i]] <- ggplot(data = dat, aes(x = x)) +  coord_cartesian(ylim = ylim) + labs(title = main, subtitle = sub, y = "", x = "") +
geom_line(aes(y = y), color = "navy") +
geom_ribbon(aes(x = x, ymax = y.upper, ymin = y.lower), fill="steelblue", alpha=.5)
}
do.call(grid.arrange, c(g, ...))
}
}
.impact(ce, int.date = int.date, ncol = 2)
library(CausalArima)
library(CausalArima)
library(CausalArima)
y <- 0.5*seq(0.5, 250, by = 0.5) + rnorm(500, sd = 6)
dates <- seq.Date(from = as.Date("2014-01-05"), by = "days", length.out = 500)
int.date <- as.Date("2015-04-01")
horizon <- c(as.Date("2015-04-10"), as.Date("2015-04-20"))
y.new <- y ; y.new[dates >= int.date] <- y.new[dates >= int.date]*1.25
start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
CausalArima<-function(y, auto = TRUE, order = c(0, 0, 0), seasonal = c(0, 0, 0), ic = "aic", xreg = NULL, dates,
int.date, arima.args = list(), auto.args = list(), nboot = NULL){
### param checks
if(class(y) != "ts") stop("y must be an object of class ts")
if(!missing(xreg)) {
if(!is.matrix(xreg) && !is.data.frame(xreg) && !is.numeric(xreg))
stop("`xreg` must be a numeric vector, matrix or data.frame")
xreg <- as.matrix(xreg)
if(nrow(xreg) != length(y)) stop("nrow(xreg) != length(y)")
}
if(!any(class(dates) %in% c("Date", "POSIXct", "POSIXlt", "POSIXt")))
stop("`dates` must be a vector of class Date")
if(length(dates) != length(y)) stop("length(dates) != length(y)")
if(length(int.date) != 1 || !any(class(dates) %in% c("Date", "POSIXct", "POSIXlt", "POSIXt")))
stop("`int.date` must be a Date of length 1")
if(!missing(nboot) && (!is.numeric(nboot) | nboot <= 0)) stop("`nboot` must be a positive numeric value")
### STEP 1. Subsetting the data: before and after the intervention date
ind<-dates>=int.date
y.00<-y[!ind]
y.01<-y[ind]
if(!is.null(xreg)) {
xreg0<-xreg[!ind,]
xreg1<-xreg[ind,]
} else {
xreg0 <- NULL
xreg1 <- NULL
}
### STEP 2. Model estimation in the pre-intervention period
start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
if(auto){
model <- do.call("auto.arima", c(list(y = ts(y.00, start = start, frequency = frequency(y))),
list(ic = ic), list(xreg = xreg0), auto.args))
} else {
model <- do.call("Arima", c(list(y = ts(y.00, start = start, frequency = frequency(y))),
list(order = order), list(seasonal = seasonal), list(xreg = xreg0),
arima.args))
}
### STEP 3. Forecasting the counterfactual outcome in the absence of intervention
h<-length(y.01)
fcast<-forecast(model, xreg = xreg1, h = h)
mean.fcast.0<-as.numeric(fcast$mean)
# Check
if(sum(y<0, na.rm = T)==0 & sum(mean.fcast.0<0, na.rm = T)>0){print("warning: negative forecasts for a positive variable")
print(mean.fcast.0[mean.fcast.0<0])}
if(sum(y<0, na.rm = T)==0 & sum(model$fitted<0, na.rm = T)>0){"warning: negative fitted for a positive variable"}
### STEP 4. Causal effect computation: direct comparison between the observed outcome (y.01) and the
#           predicted counterfactual (mean.fcast.0)
causal.effect.0 <- y.01 - mean.fcast.0
### STEP 5. Test statistics
## Extracting
d <- model$arma[6]; D <- model$arma[7]; S <- model$arma[5]
coef <- model$coef
sig2 <- model$sigma2
ar  <- coef[ substr(names(coef), 1, 2) == "ar"  ]
ma  <- coef[ substr(names(coef), 1, 2) == "ma"  ]
sar <- coef[ substr(names(coef), 1, 3) == "sar" ]
sma <- coef[ substr(names(coef), 1, 3) == "sma" ]
## MA(inf)
par <- .sarma2larma(ar = ar, ma = ma, sar = sar, sma = sma, S = S)
psi <- c(1, ARMAtoMA(ar = par$ar, ma = par$ma, lag.max = h-1))
## Stats (tau, sum.tau, avg.tau)
# Removing NA's
psi <- psi[!is.na(causal.effect.0)]
tau  <- causal.effect.0[!is.na(causal.effect.0)]
sum.tau <- cumsum(tau)
avg.tau <- cumsum(tau) / seq(1, length(tau), 1)
# Gaussian based inference
norm <- .norm.inf(stat1 = tau, stat2 = sum.tau, stat3 = avg.tau, sig2 = sig2, psi = psi)
# Bootstrap based inference
boot <- if ( NROW(nboot) > 0 && is.finite(nboot) && nboot >= 1)
{
nboot <- round(nboot[1])
.boot.inf(stat1 = tau, stat2 = sum.tau, stat3 = avg.tau, psi = psi, res = residuals(model),
nrep = nboot)
}
else
{
NULL
}
### STEP 6. Saving results
my_list <- list(norm = norm, boot = boot, causal.effect = causal.effect.0, model = model,
dates = dates, int.date = int.date, y = y, forecast = mean.fcast.0)
class(my_list) <- "cArima"
return(my_list)
}
# ------------------------------------------------------------------------------
##################################################################################
## Merge AR(p) and SAR(P); the same for MA(q) and SMA(Q)
##################################################################################
.sarma2larma <- function(ar = NULL, ma = NULL, sar = NULL, sma = NULL, S = 12)
{
#### Adjust
if ( NROW(ar) > 0 ) { ar <- -ar }
if ( NROW(sar) > 0 ) { sar <- -sar }
#### model
list(
ar = -.long(p = ar, ps = sar, s = S),
ma =  .long(p = ma, ps = sma, s = S) )
}
##################################################################################
## Merge short and seasonal components
##################################################################################
.long <- function(p, ps, s)
{
#### Settings
np  <- NROW( p )
nps <- NROW( ps )
####
cp  <- if ( np > 0 ) { c(1, p) } else { 1 }
cps <- if ( nps > 0 )
{
ind <- seq(from = s, by = s, length.out = nps)
x1 <- numeric(s * nps)
x1[ind] <- ps
c(1, x1)
}
else
{
1
}
#### Answer
convolve(cp, rev(cps), type = "open")[-1]
}
##################################################################################
## Compute variance of the point, cumulative and temporal average effect
##################################################################################
.norm.inf <- function(stat1, stat2, stat3, sig2, psi)
{
#### Settings
np <- NROW(psi)
## Stat 1: tau ~ Normal
psi1 <- psi
sd1  <- sqrt(sig2 * cumsum(psi^2))
z1 <- (stat1 - 0) / sd1
## Stat 2: delta ~ Normal
psi2 <- cumsum(psi)
sd2  <- sqrt(sig2 * cumsum(psi2^2))
z2 <- (stat2 - 0) / sd2
## Stat 3: avg.tau ~ Normal
sd3 <- sd2 / seq(1, np, 1)
z3 <- (stat3 - 0) / sd3
#### Gaussian based inference
inf <- cbind(
tau = stat1, sd.tau = sd1,
pvalue.tau.l = pnorm(z1), pvalue.tau.b = 2 * (1 - pnorm(abs(z1))), pvalue.tau.r = 1 - pnorm(z1),
sum.tau = stat2, sd.sum = sd2,
pvalue.sum.l = pnorm(z2), pvalue.sum.b = 2 * (1 - pnorm(abs(z2))), pvalue.sum.r = 1 - pnorm(z2),
avg.tau = stat3, sd.avg = sd3,
pvalue.avg.l = pnorm(z3), pvalue.avg.b = 2 * (1 - pnorm(abs(z3))), pvalue.avg.r = 1 - pnorm(z3))
#### Answer
list(type = "norm", inf = inf)
}
# ------------------------------------------------------------------------------
.boot.inf <- function(stat1, stat2, stat3, psi, res, nrep)
{
#### Settings
np <- NROW(psi)
psi1 <- psi
psi2 <- cumsum(psi)
fun <- function(eps, psi)
{
convolve(eps, psi, conj = FALSE, type = "open")[NROW(eps):(2*NROW(eps)-1)]
}
#### Remove NA from res
res <- na.omit(as.numeric(res))
#### Bootstrap residuals
bootm <- as.data.frame(
matrix( sample(x = res, size = np * nrep, replace = TRUE), np, nrep ) )
#### stat1 (arrange by row, replications by col)
boot1 <- mapply(FUN = fun, eps = bootm, MoreArgs = list(psi = psi1))
#### stat2 (arrange by row, replications by col)
boot2 <- mapply(FUN = fun, eps = bootm, MoreArgs = list(psi = psi2))
#### stat3
boot3 <- boot2 / seq(1, np, 1)
#### p-values
pv1.l <- pv1.b <- pv1.r <- pv2.l <- pv2.b <- pv2.r <- pv3.l <- pv3.b <- pv3.r <- rep.int(NA, np)
for (i in 1 : np)
{
stat <- stat1[i]
boot <- boot1[i, ]
pv1.l[i] <- mean(boot < stat)
pv1.b[i] <- mean( boot < -abs(stat) | boot > abs(stat) )
pv1.r[i] <- mean(stat < boot)
stat <- stat2[i]
boot <- boot2[i, ]
pv2.l[i] <- mean(boot < stat)
pv2.b[i] <- mean( boot < -abs(stat) | boot > abs(stat) )
pv2.r[i] <- mean(stat < boot)
stat <- stat3[i]
boot <- boot3[i, ]
pv3.l[i] <- mean(boot < stat)
pv3.b[i] <- mean( boot < -abs(stat) | boot > abs(stat) )
pv3.r[i] <- mean(stat < boot)
}
#### Inference
inf <- cbind(
tau = stat1,
pvalue.tau.l = pv1.l, pvalue.tau.b = pv1.b, pvalue.tau.r = pv1.r,
sum.tau = stat2,
pvalue.sum.l = pv2.l, pvalue.sum.b = pv2.b, pvalue.sum.r = pv2.r,
avg.tau = stat3,
pvalue.avg.l = pv3.l, pvalue.avg.b = pv3.b, pvalue.avg.r = pv3.r)
#### Answer
list(type = "bootstrap", nrep = nrep, inf = inf)
}
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
library(forecast)
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
.forecast <- function(cArima, horizon = NULL, ...){
# Settings
dates <- cArima$dates[!is.na(cArima$y)]
int.date <- cArima$int.date
observed <- na.omit(cArima$y)
forecasted <- na.omit(c(cArima$model$fitted, cArima$forecast))
start <- which(dates == int.date) - round(0.4 * sum(dates < int.date))
end <- length(forecasted)
x <- dates[start:end]
# Plot
dat <- data.frame(x = x, forecasted.cut = forecasted[start:(end - 1)], observed.cut = observed[start:(end - 1)])
ylim <- c(min(dat[, -1]), max(dat[, -1]))
main <- "Forecasted series"
g <- ggplot(data = dat, aes(x = x, colour = "Legend")) +  coord_cartesian(ylim = ylim) + labs(title = main, y = "", x = "") +
geom_line(aes(y = forecasted.cut, color = "Forecast"))  +
geom_line(aes(y = observed.cut, color = "Observed")) +
scale_colour_manual(values = c("deepskyblue", "gray40")) +
geom_vline(aes(xintercept = int.date, linetype = paste(int.date))) +
scale_linetype_manual(values = "dashed") +
labs(color="Time series", linetype="Intervention date") +
guides(colour = guide_legend(order = 1), linetype = guide_legend(order = 2))
if(missing(horizon)){ g } else {
gg <- list()
for(i in 1:length(horizon)){
gg[[i]] <- g + xlim(c(start, horizon[i])) + labs(title = main, subtitle = paste("Time horizon ", i, sep = ""), y = "", x = "")
}
do.call(grid.arrange, c(gg, ...))
}
}
.forecast(cArima = ce)
.forecast <- function(cArima, horizon = NULL, ...){
# Settings
dates <- cArima$dates[!is.na(cArima$y)]
int.date <- cArima$int.date
observed <- na.omit(cArima$y)
forecasted <- na.omit(c(cArima$model$fitted, cArima$forecast))
start <- which(dates == int.date) - round(0.4 * sum(dates < int.date))
end <- length(forecasted)
x <- dates[start:end]
# Plot
dat <- data.frame(x = x, forecasted.cut = forecasted[start:end], observed.cut = observed[start:end])
ylim <- c(min(dat[, -1]), max(dat[, -1]))
main <- "Forecasted series"
g <- ggplot(data = dat, aes(x = x, colour = "Legend")) +  coord_cartesian(ylim = ylim) + labs(title = main, y = "", x = "") +
geom_line(aes(y = forecasted.cut, color = "Forecast"))  +
geom_line(aes(y = observed.cut, color = "Observed")) +
scale_colour_manual(values = c("deepskyblue", "gray40")) +
geom_vline(aes(xintercept = int.date, linetype = paste(int.date))) +
scale_linetype_manual(values = "dashed") +
labs(color="Time series", linetype="Intervention date") +
guides(colour = guide_legend(order = 1), linetype = guide_legend(order = 2))
if(missing(horizon)){ g } else {
gg <- list()
for(i in 1:length(horizon)){
gg[[i]] <- g + xlim(c(start, horizon[i])) + labs(title = main, subtitle = paste("Time horizon ", i, sep = ""), y = "", x = "")
}
do.call(grid.arrange, c(gg, ...))
}
}
.forecast(cArima = ce)
library(ggplot2)
.forecast(cArima = ce)
.forecast(cArima = ce, horizon = horizon)
library(gridExtra)
.forecast(cArima = ce, horizon = horizon)
class(horizon)
horizon
cArima <- ce
dates <- cArima$dates[!is.na(cArima$y)]
int.date <- cArima$int.date
observed <- na.omit(cArima$y)
forecasted <- na.omit(c(cArima$model$fitted, cArima$forecast))
start <- which(dates == int.date) - round(0.4 * sum(dates < int.date))
end <- length(forecasted)
x <- dates[start:end]
# Plot
dat <- data.frame(x = x, forecasted.cut = forecasted[start:end], observed.cut = observed[start:end])
ylim <- c(min(dat[, -1]), max(dat[, -1]))
main <- "Forecasted series"
g <- ggplot(data = dat, aes(x = x, colour = "Legend")) +  coord_cartesian(ylim = ylim) + labs(title = main, y = "", x = "") +
geom_line(aes(y = forecasted.cut, color = "Forecast"))  +
geom_line(aes(y = observed.cut, color = "Observed")) +
scale_colour_manual(values = c("deepskyblue", "gray40")) +
geom_vline(aes(xintercept = int.date, linetype = paste(int.date))) +
scale_linetype_manual(values = "dashed") +
labs(color="Time series", linetype="Intervention date") +
guides(colour = guide_legend(order = 1), linetype = guide_legend(order = 2))
g
g + xlim(c(start, horizon[1]))
start
dates[start]
g + xlim(c(dates[start], horizon[1]))
int.date
horizon[1]
g + xlim(c(dates[start], horizon[2]))
tail(dates)
.forecast <- function(cArima, horizon = NULL, ...){
# Settings
dates <- cArima$dates[!is.na(cArima$y)]
int.date <- cArima$int.date
observed <- na.omit(cArima$y)
forecasted <- na.omit(c(cArima$model$fitted, cArima$forecast))
start <- which(dates == int.date) - round(0.4 * sum(dates < int.date))
end <- length(forecasted)
x <- dates[start:end]
# Plot
dat <- data.frame(x = x, forecasted.cut = forecasted[start:end], observed.cut = observed[start:end])
ylim <- c(min(dat[, -1]), max(dat[, -1]))
main <- "Forecasted series"
g <- ggplot(data = dat, aes(x = x, colour = "Legend")) +  coord_cartesian(ylim = ylim) + labs(title = main, y = "", x = "") +
geom_line(aes(y = forecasted.cut, color = "Forecast"))  +
geom_line(aes(y = observed.cut, color = "Observed")) +
scale_colour_manual(values = c("deepskyblue", "gray40")) +
geom_vline(aes(xintercept = int.date, linetype = paste(int.date))) +
scale_linetype_manual(values = "dashed") +
labs(color="Time series", linetype="Intervention date") +
guides(colour = guide_legend(order = 1), linetype = guide_legend(order = 2))
if(missing(horizon)){ g } else {
gg <- list()
for(i in 1:length(horizon)){
gg[[i]] <- g + xlim(c(dates[start], horizon[i])) + labs(title = main, subtitle = paste("Time horizon ", i, sep = ""), y = "", x = "")
}
do.call(grid.arrange, c(gg, ...))
}
}
.forecast(cArima = ce, horizon = horizon, nrow = 2, ncol = 1)
library(CausalMBSTS)
library(CausalArima)
## Example 1 (daily data, no predictors)
# Generating a time series of length 1000 and a vector of dates
y <- 0.5*seq(0.5, 250, by = 0.5) + rnorm(500, sd = 6)
dates <- seq.Date(from = as.Date("2014-01-05"), by = "days", length.out = 500)
# Adding a fictional intervention
int.date <- as.Date("2015-04-01")
horizon <- c(as.Date("2015-04-10"), as.Date("2015-04-20"))
y.new <- y ; y.new[dates >= int.date] <- y.new[dates >= int.date]*1.25
# Plot
oldpar <- par(no.readonly = TRUE)
plot(y = y.new, x = dates, type = "l", col = "cadetblue", xlim = c(as.Date("2014-10-01"), tail(dates, 1)))
lines(y = y, x = dates, col = "orange")
# Causal effect estimation
start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
dim(ce$norm$inf)
ce$norm$inf
plot(ce, type = "forecast")
plot(ce, type = "impact", horizon = horizon, nrow = 2, ncol = 1)
plot(ce, type = "residuals")
rlang::last_error()
plot(ce, type = "forecast")
prova <- function(x, horizon = NULL){
if(missing(horizon)){print(paste(x, "horizon is missing"))} else {print(paste(x, "horizon is not missing"))}
}
prova(1)
prova(1, horizon = 2)
library(CausalArima)
## Example 1 (daily data, no predictors)
# Generating a time series of length 1000 and a vector of dates
y <- 0.5*seq(0.5, 250, by = 0.5) + rnorm(500, sd = 6)
dates <- seq.Date(from = as.Date("2014-01-05"), by = "days", length.out = 500)
# Adding a fictional intervention
int.date <- as.Date("2015-04-01")
horizon <- c(as.Date("2015-04-10"), as.Date("2015-04-20"))
y.new <- y ; y.new[dates >= int.date] <- y.new[dates >= int.date]*1.25
# Causal effect estimation
start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
# Plot
plot(ce, type = "forecast")
plot(ce, type = "impact", horizon = horizon, nrow = 2, ncol = 1)
plot(ce, type = "impact")
plot(ce, type = "forecast", horizon = horizon)
rlang::last_error()
rlang::last_trace()
plot(ce, type = "impact", horizon = NULL)
library(CausalArima)
## Example 1 (daily data, no predictors)
# Generating a time series of length 1000 and a vector of dates
y <- 0.5*seq(0.5, 250, by = 0.5) + rnorm(500, sd = 6)
dates <- seq.Date(from = as.Date("2014-01-05"), by = "days", length.out = 500)
# Adding a fictional intervention
int.date <- as.Date("2015-04-01")
horizon <- c(as.Date("2015-04-10"), as.Date("2015-04-20"))
y.new <- y ; y.new[dates >= int.date] <- y.new[dates >= int.date]*1.25
# Causal effect estimation
start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
# Plot
plot(ce, type = "forecast")
plot(ce, type = "forecast")
.impact <- function(cArima, horizon = NULL, alpha = 0.05, ...){
# Settings
dates <- cArima$dates[!is.na(cArima$causal.effect)]
int.date <- cArima$int.date
x <- dates[dates >= int.date]
y <- na.omit(cArima$causal.effect)
y.upper <- y + cArima$norm$inf[, "sd.tau"]*qnorm(1-alpha/2)
y.lower <- y - cArima$norm$inf[, "sd.tau"]*qnorm(1-alpha/2)
# Plot
main <- "Point effect"
dat <- data.frame(x = x, y = y, y.upper = y.upper, y.lower = y.lower)
ylim <- c(min(dat[, "y.lower"]), max(dat[, "y.upper"]))
g <- ggplot(data = dat, aes(x = x)) +  coord_cartesian(ylim = ylim) + labs(title = main, y = "", x = "") +
geom_line(aes(y = y), color = "navy") +
geom_ribbon(aes(x = x, ymax = y.upper, ymin = y.lower), fill = "steelblue", alpha =.5)
if(is.null(horizon)){ print(g) } else {
gg <- list()
for(i in 1:length(horizon)){
gg[[i]] <- g + xlim(int.date, horizon[i]) + labs(title = main, subtitle = paste("Time horizon ", i, sep = ""), y = "", x = "")
}
do.call(grid.arrange, c(gg, ...))
}
}
.impact(ce)
library(CausalArima)
y <- 0.5*seq(0.5, 250, by = 0.5) + rnorm(500, sd = 6)
dates <- seq.Date(from = as.Date("2014-01-05"), by = "days", length.out = 500)
# Adding a fictional intervention
int.date <- as.Date("2015-04-01")
horizon <- c(as.Date("2015-04-10"), as.Date("2015-04-20"))
y.new <- y ; y.new[dates >= int.date] <- y.new[dates >= int.date]*1.25
# Causal effect estimation
start<-as.numeric(strftime(as.Date(dates[1], "%Y-%m-%d"), "%u"))
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic", dates = dates, int.date = int.date)
# Plot
plot(ce, type = "forecast")
plot(ce, type = "impact")
summary.cArima<- function(cArima, type, horizon = NULL){
if(!is.null(horizon)){
## Settings & removing NA's
int.date <- cArima$int.date
dates <- cArima$dates
ind <- which(dates[dates >= int.date][!is.na(cArima$causal.effect)] %in% horizon)
ncol <- 1 + dim(cArima[[type]]$inf)[2]
summary <- data.frame(matrix(nrow = length(horizon), ncol = ncol))
colnames(summary) <- c("Time horizon", colnames(cArima[[type]]$inf))
summary[, 1] <- horizon
summary[, 2:ncol] <- cArima[[type]]$inf[ind, ]
summary
} else {
h <- dim(cArima[[type]]$inf)[1]
cArima[[type]]$inf[h, ]
}
}
summary(ce, type = "norm")
summary(ce, type = "norm", horizon = horizon)
class(summary(ce, type = "norm", horizon = horizon))
library(CausalArima)
library(CausalArima)
summary(ce, type = "norm")
library(CausalArima)
summary(ce, type = "norm")
summary(ce, type = "boot", horizon = horizon)
summary(ce, type = "boot")
ce <- CausalArima(y = ts(y.new, start = start, frequency = 1), auto = TRUE, ic = "aic",
dates = dates, int.date = int.date, nboot = 1000)
summary(ce, type = "boot")
library(CausalArima)
